using IFY.Phorm.Execution;
using Microsoft.Data.SqlClient;

namespace IFY.Phorm.SqlClient;

/// <summary>
/// Captures and processes informational and error messages generated by a SQL Server connection during command
/// execution.
/// </summary>
/// <remarks>This class subscribes to SQL Server informational messages and errors via the provided <see
/// cref="SqlConnection"/> instance. It is typically used to relay SQL Server messages to a console or logging mechanism
/// during the execution of database commands. Instances of this class should be disposed to unsubscribe from SQL Server
/// events and release resources.</remarks>
public class SqlConsoleMessageCapture : AbstractConsoleMessageCapture
{
    private readonly SqlConnection _conn;

    /// <summary>
    /// Initializes a new instance of the SqlConsoleMessageCapture class to capture informational messages from the
    /// specified SQL connection during the session.
    /// </summary>
    /// <remarks>The constructor subscribes to the InfoMessage event of the provided SqlConnection to capture
    /// messages such as warnings or informational output generated by SQL Server. Ensure that the connection remains
    /// open and valid for the duration of message capture.</remarks>
    /// <param name="session">The session context used to associate the message capture with a specific database operation.</param>
    /// <param name="commandGuid">The unique identifier for the command associated with this message capture instance.</param>
    /// <param name="conn">The SqlConnection from which informational messages will be captured. Cannot be null.</param>
    public SqlConsoleMessageCapture(AbstractPhormSession session, Guid commandGuid, SqlConnection conn)
        : base(session, commandGuid)
    {
        _conn = conn;
        conn.InfoMessage += captureInfoMessage;
    }

    /// <inheritdoc/>
    public override bool ProcessException(Exception ex)
    {
        if (ex is SqlException sqlException)
        {
            HasError = true;
            fromSqlErrors(sqlException.Errors, true);
            return true;
        }
        return false;
    }

    private void captureInfoMessage(object sender, SqlInfoMessageEventArgs e)
    {
        // TODO: How to limit to only events for this session?
        fromSqlErrors(e.Errors, false);
    }

    private void fromSqlErrors(SqlErrorCollection errors, bool isException)
    {
        foreach (SqlError err in errors)
        {
            OnConsoleMessage(new ConsoleMessage
            {
                IsError = isException,
                Level = err.Class,
                Source = $"{err.Procedure} @ {err.LineNumber}",
                Message = err.Message
            });
        }
    }

    /// <inheritdoc/>
    public override void Dispose()
    {
        _conn.InfoMessage -= captureInfoMessage;
        GC.SuppressFinalize(this);
    }
}
